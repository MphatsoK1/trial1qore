<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Word Search Adventure</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Fredoka', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow-x: hidden;
      position: relative;
      padding-bottom: 80px;
      min-height: 100vh;
    }
    
    .star-bg {
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      z-index: 0;
      pointer-events: none;
    }
    
    .star {
      position: absolute;
      background: white;
      border-radius: 50%;
      animation: twinkle 3s infinite;
    }
    
    @keyframes twinkle {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }
    
    .content-wrapper {
      position: relative;
      z-index: 1;
      width: 100%;
      max-width: 100%;
      padding: 0 10px;
      box-sizing: border-box;
    }
    
    .grid-container {
      width: 100%;
      overflow-x: auto;
      padding: 10px 0;
      -webkit-overflow-scrolling: touch;
    }
    
    .grid-wrapper {
      display: inline-block;
      min-width: min-content;
      margin: 0 auto;
    }
    
    .grid-cell {
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, #ffffff, #f0f9ff);
      border: 2px solid #93c5fd;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      font-weight: 700;
      font-size: 16px;
      color: #1e40af;
      transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
      flex-shrink: 0;
    }
    
    @media (max-width: 480px) {
      .grid-cell {
        width: 35px;
        height: 35px;
        font-size: 14px;
      }
    }
    
    @media (max-width: 380px) {
      .grid-cell {
        width: 30px;
        height: 30px;
        font-size: 12px;
      }
    }
    
    @media (max-width: 320px) {
      .grid-cell {
        width: 28px;
        height: 28px;
        font-size: 11px;
      }
    }
    
    .grid-cell:hover {
      transform: scale(1.1) rotate(3deg);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      z-index: 10;
    }
    
    .selected {
      background: linear-gradient(135deg, #fbbf24, #f59e0b) !important;
      color: white !important;
      transform: scale(1.05);
      border-color: #d97706;
      animation: pulse 0.5s;
    }
    
    .found-cell {
      background: linear-gradient(135deg, #34d399, #10b981) !important;
      color: white !important;
      border-color: #059669;
      animation: bounce 0.6s;
    }
    
    .found-cell-1 { background: linear-gradient(135deg, #34d399, #10b981) !important; }
    .found-cell-2 { background: linear-gradient(135deg, #60a5fa, #3b82f6) !important; }
    .found-cell-3 { background: linear-gradient(135deg, #f472b6, #ec4899) !important; }
    .found-cell-4 { background: linear-gradient(135deg, #a78bfa, #8b5cf6) !important; }
    .found-cell-5 { background: linear-gradient(135deg, #fbbf24, #f59e0b) !important; }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1.05); }
      50% { transform: scale(1.1); }
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      25% { transform: translateY(-5px); }
      50% { transform: translateY(0); }
      75% { transform: translateY(-3px); }
    }
    
    .word-item {
      display: inline-flex;
      align-items: center;
      margin: 4px;
      padding: 6px 12px;
      background: linear-gradient(135deg, #ddd6fe, #c4b5fd);
      border-radius: 16px;
      font-weight: 600;
      color: #5b21b6;
      transition: all 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      font-size: 14px;
    }
    
    @media (max-width: 380px) {
      .word-item {
        font-size: 12px;
        padding: 4px 10px;
        margin: 3px;
      }
    }
    
    .word-item.found {
      background: linear-gradient(135deg, #86efac, #4ade80);
      color: white;
      animation: foundWord 0.5s;
    }
    
    @keyframes foundWord {
      0% { transform: scale(1); }
      50% { transform: scale(1.1) rotate(3deg); }
      100% { transform: scale(1); }
    }
    
    .word-item.found::before {
      content: '‚≠ê';
      margin-right: 4px;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .timer-danger {
      animation: timerBlink 0.5s infinite;
      color: #dc2626 !important;
    }
    
    @keyframes timerBlink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .game-card {
      background: white;
      border-radius: 16px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
      animation: slideIn 0.5s;
      margin-bottom: 12px;
      padding: 16px;
      width: 100%;
      box-sizing: border-box;
    }
    
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      transition: all 0.3s;
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(245, 158, 11, 0.4);
    }
    
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 100;
      align-items: center;
      justify-content: center;
      padding: 16px;
      box-sizing: border-box;
    }
    
    .modal.active {
      display: flex;
    }
    
    .modal-content {
      background: white;
      padding: 24px;
      border-radius: 16px;
      max-width: 90%;
      width: 100%;
      text-align: center;
      animation: modalPop 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      max-height: 85vh;
      overflow-y: auto;
      box-sizing: border-box;
    }
    
    @keyframes modalPop {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    
    .trophy {
      font-size: 60px;
      animation: trophyRotate 2s ease-in-out infinite;
    }
    
    @keyframes trophyRotate {
      0%, 100% { transform: rotate(-8deg); }
      50% { transform: rotate(8deg); }
    }
    
    .difficulty-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }
    
    .level-progress {
      height: 6px;
      background: #e5e7eb;
      border-radius: 8px;
      overflow: hidden;
      margin-top: 8px;
    }
    
    .level-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #34d399, #10b981);
      transition: width 0.5s;
    }
    
    .fab {
      position: fixed;
      bottom: 80px;
      right: 12px;
      z-index: 50;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .fab:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    @keyframes fall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }

    .loading-spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      animation: spinLoader 1s linear infinite;
      margin: 16px auto;
    }

    @keyframes spinLoader {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .controls-container {
      position: relative;
      padding-bottom: 70px;
    }
    
    .controls-wrapper {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 16px;
      padding: 0 8px;
    }
    
    .control-btn {
      padding: 10px 16px;
      border-radius: 50px;
      font-weight: bold;
      font-size: 14px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      transition: all 0.3s;
      flex: 1;
      min-width: 90px;
      max-width: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }
    
    @media (max-width: 380px) {
      .control-btn {
        padding: 8px 12px;
        font-size: 13px;
        min-width: 80px;
      }
    }
    
    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      padding: 8px 12px;
      display: flex;
      justify-content: space-around;
      text-align: center;
      border-top: 1px solid #e5e7eb;
      z-index: 40;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    }
    
    .nav-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #6b7280;
      text-decoration: none;
      padding: 6px 0;
      font-size: 11px;
      flex: 1;
      max-width: 80px;
    }
    
    .nav-item:hover, .nav-item.active {
      color: #3b82f6;
    }
    
    .nav-icon {
      font-size: 20px;
      margin-bottom: 2px;
    }
    
    .mobile-optimized-grid {
      display: grid;
      gap: 4px;
      justify-content: center;
      margin: 0 auto;
      width: fit-content;
      max-width: 100%;
    }

    .voice-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      background: #22c55e;
      border-radius: 50%;
      margin-left: 8px;
      animation: pulse-voice 1.5s infinite;
    }
    
    @keyframes pulse-voice {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }
  </style>
</head>
<body class="flex flex-col items-center min-h-screen p-3">

  <!-- Star Background -->
  <div class="star-bg" id="starBg"></div>

  <div class="content-wrapper">
    
    <!-- Tutorial Modal -->
    <div id="tutorialModal" class="modal">
      <div class="modal-content">
        <div class="text-5xl mb-4">üéÆ</div>
        <h2 class="text-2xl font-bold text-purple-600 mb-4">Welcome to Word Search Adventure!</h2>
        <div class="text-left space-y-3 mb-6">
          <p class="text-base"><strong>üéØ Goal:</strong> Find all hidden words in the grid!</p>
          <p class="text-base"><strong>üëÜ How to Play:</strong> Click letters in order to spell words</p>
          <p class="text-base"><strong>‚≠ê Tips:</strong> Words can go horizontally, vertically, or diagonally</p>
          <p class="text-base"><strong>üí° Need Help?:</strong> Use the hint button!</p>
          <p class="text-base"><strong>üé® Overlapping:</strong> Words can share letters - different colors help you see them!</p>
          <p class="text-base"><strong>üîä Sound:</strong> Turn on sound for fun effects and voice guidance!</p>
        </div>
        <button onclick="startGame()" class="bg-gradient-to-r from-green-400 to-green-600 text-white px-6 py-3 rounded-full text-lg font-bold hover:scale-105 transition w-full">
          Let's Play! üöÄ
        </button>
      </div>
    </div>

    <!-- Hint Modal -->
    <div id="hintModal" class="modal">
      <div class="modal-content">
        <div class="text-5xl mb-4">üí°</div>
        <h2 class="text-xl font-bold text-yellow-600 mb-4">Hint!</h2>
        <p class="text-base mb-2" id="hintMessage"></p>
        <p class="text-sm text-gray-600 mb-6" id="hintDetail"></p>
        <button onclick="closeHintModal()" class="bg-gradient-to-r from-blue-400 to-blue-600 text-white px-6 py-3 rounded-full text-base font-bold hover:scale-105 transition w-full">
          Got It! üëç
        </button>
      </div>
    </div>

    <!-- Time Up Modal -->
    <div id="timeUpModal" class="modal">
      <div class="modal-content">
        <div class="text-5xl mb-4">‚è∞</div>
        <h2 class="text-2xl font-bold text-red-600 mb-4">Time's Up!</h2>
        <p class="text-lg mb-2" id="timeUpMessage"></p>
        <p class="text-base text-gray-600 mb-6">Don't worry, let's try the next challenge!</p>
        <button onclick="nextLevel()" class="bg-gradient-to-r from-green-400 to-green-600 text-white px-6 py-3 rounded-full text-lg font-bold hover:scale-105 transition w-full">
          Next Level! üéØ
        </button>
      </div>
    </div>

    <!-- Loading Modal -->
    <div id="loadingModal" class="modal">
      <div class="modal-content">
        <div class="loading-spinner"></div>
        <p class="text-base text-gray-600 mt-4">Loading new words...</p>
      </div>
    </div>

    <!-- Completion Modal -->
    <div id="completionModal" class="modal">
      <div class="modal-content">
        <div class="trophy">üèÜ</div>
        <h2 class="text-2xl font-bold text-yellow-500 mb-4">Amazing Job!</h2>
        <p class="text-lg mb-2" id="completionMessage"></p>
        <p class="text-base text-gray-600 mb-6" id="completionStats"></p>
        <button onclick="nextLevel()" class="bg-gradient-to-r from-blue-400 to-blue-600 text-white px-6 py-3 rounded-full text-lg font-bold hover:scale-105 transition w-full">
          Next Challenge! üéØ
        </button>
      </div>
    </div>

    <!-- Header -->
    <div class="game-card flex justify-between items-center">
      <div>
        <h1 class="text-xl font-bold text-purple-600 flex items-center gap-2">
          <i class='bx bxs-star text-yellow-400'></i> Word Hunt
          <span class="voice-indicator" id="voiceIndicator" style="display: none;"></span>
        </h1>
        <div class="flex items-center gap-2 mt-1">
          <span class="difficulty-badge bg-blue-100 text-blue-700" id="difficultyBadge">Level 1</span>
          <span class="text-xs text-gray-600">Score: <strong id="totalScore">0</strong></span>
        </div>
      </div>
      <div class="text-right">
        <div class="text-2xl font-bold" id="timer">3:00</div>
        <div class="text-xs text-gray-500">Time Left</div>
      </div>
    </div>

    <!-- Level Progress -->
    <div class="game-card">
      <div class="flex justify-between text-xs mb-1">
        <span class="text-gray-600">Progress</span>
        <span class="font-bold text-purple-600" id="score">0/5</span>
      </div>
      <div class="level-progress">
        <div class="level-progress-bar" id="progressBar" style="width: 0%"></div>
      </div>
    </div>

    <!-- Grid -->
    <div class="game-card p-4">
      <div class="grid-container">
        <div class="grid-wrapper">
          <div id="grid" class="mobile-optimized-grid text-center select-none">
            <!-- JS generates cells -->
          </div>
        </div>
      </div>
    </div>

    <!-- Words List -->
    <div class="game-card">
      <p class="text-xs text-gray-600 mb-3 font-semibold">üîç Find These Words:</p>
      <div id="word-list" class="flex flex-wrap justify-center"></div>
    </div>

    <!-- Controls -->
    <div class="controls-container">
      <div class="controls-wrapper">
        <button id="hint-btn" class="control-btn btn-primary text-white">
          üí° Hint
        </button>
        <button id="clear-btn" class="control-btn bg-gradient-to-r from-gray-400 to-gray-600 text-white">
          üîÑ Clear
        </button>
        <button id="sound-btn" class="control-btn bg-gradient-to-r from-pink-400 to-pink-600 text-white">
          üîä Sound
        </button>
      </div>
    </div>

  </div>

  

  <script>
    // Enhanced word banks with more words
    const wordBanks = {
      easy: [
        ["CAT", "DOG", "SUN", "MOON", "STAR", "FISH", "BIRD", "TREE"],
        ["HAT", "BAT", "RAT", "MAT", "CAR", "BUS", "BOAT", "SHIP"],
        ["BEE", "ANT", "FLY", "BUG", "WEB", "BIRD", "FROG", "BEAR"],
        ["RED", "BLUE", "PINK", "GOLD", "GRAY", "BLACK", "WHITE", "GREEN"],
        ["BALL", "DOLL", "KITE", "BIKE", "GAME", "BOOK", "TOY", "PUZZLE"]
      ],
      medium: [
        ["APPLE", "GRAPE", "LEMON", "MELON", "BERRY", "ORANGE", "BANANA", "CHERRY"],
        ["TIGER", "ZEBRA", "PANDA", "KOALA", "EAGLE", "LION", "BEAR", "WOLF"],
        ["HAPPY", "SMILE", "LAUGH", "DANCE", "SING", "JUMP", "PLAY", "RUN"],
        ["OCEAN", "RIVER", "LAKE", "BEACH", "WAVE", "SAND", "WATER", "FISH"],
        ["PIZZA", "BREAD", "SALAD", "PASTA", "RICE", "SOUP", "CAKE", "COOKIE"]
      ],
      hard: [
        ["DRAGON", "CASTLE", "WIZARD", "KNIGHT", "MAGIC", "SWORD", "SHIELD", "KINGDOM"],
        ["ROCKET", "PLANET", "GALAXY", "COMET", "ORBIT", "SPACE", "STAR", "MOON"],
        ["JUNGLE", "FOREST", "DESERT", "MOUNTAIN", "VALLEY", "CANYON", "RIVER", "OCEAN"],
        ["RAINBOW", "THUNDER", "LIGHTNING", "TORNADO", "BREEZE", "WEATHER", "CLOUD", "STORM"],
        ["DOLPHIN", "PENGUIN", "OCTOPUS", "TURTLE", "WHALE", "SHARK", "SEAL", "OTTER"]
      ]
    };

    let currentLevel = 1;
    let currentDifficulty = 'easy';
    let currentWords = [];
    let wordPositions = {};
    let gridSize = 5;
    let gridLetters = [];
    let selectedCells = [];
    let foundWords = new Set();
    let timer = 180;
    let gameActive = false;
    let timerInterval;
    let totalScore = 0;
    let soundEnabled = true;
    let hintsUsed = 0;
    let wordColorIndex = 0;
    
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let bgMusicNode = null;
    
    // Game state persistence - Updated key to avoid conflict
    function saveGameState() {
      const gameState = {
        currentLevel,
        currentDifficulty,
        currentWords,
        wordPositions,
        gridSize,
        gridLetters,
        foundWords: Array.from(foundWords),
        timer,
        totalScore,
        soundEnabled,
        hintsUsed,
        wordColorIndex,
        gameActive,
        timestamp: Date.now()
      };
      // Use different key for word search game
      localStorage.setItem('wordSearchGameState_v2', JSON.stringify(gameState));
    }
    
    function loadGameState() {
      const savedState = localStorage.getItem('wordSearchGameState_v2');
      if (savedState) {
        try {
          const state = JSON.parse(savedState);
          const oneDay = 24 * 60 * 60 * 1000;
          if (Date.now() - state.timestamp < oneDay) {
            currentLevel = state.currentLevel;
            currentDifficulty = state.currentDifficulty;
            currentWords = state.currentWords;
            wordPositions = state.wordPositions;
            gridSize = state.gridSize;
            gridLetters = state.gridLetters;
            foundWords = new Set(state.foundWords);
            timer = state.timer;
            totalScore = state.totalScore;
            soundEnabled = state.soundEnabled;
            hintsUsed = state.hintsUsed;
            wordColorIndex = state.wordColorIndex;
            gameActive = state.gameActive;
            return true;
          }
        } catch (e) {
          console.error('Error loading game state:', e);
        }
      }
      return false;
    }
    
    function clearGameState() {
      localStorage.removeItem('wordSearchGameState_v2');
    }
    
    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }

    // Updated API endpoint for word search
    async function fetchWordsFromServer(difficulty) {
      try {
        const response = await fetch(`/api/search/get-word-set/?difficulty=${difficulty}`);
        const data = await response.json();
        
        if (data.error) {
          console.error('Error fetching words:', data.error);
          return null;
        }
        
        return data.words;
      } catch (error) {
        console.error('Failed to fetch words:', error);
        return null;
      }
    }

    // Updated API endpoint for saving session
    async function saveGameSession() {
      try {
        const sessionData = {
          player_name: 'Player',
          score: totalScore,
          level: currentLevel,
          words_found: foundWords.size,
          time_spent: 180 - timer,
          completed: foundWords.size === currentWords.length
        };
        
        const response = await fetch('/api/search/save-session/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify(sessionData)
        });
        
        const data = await response.json();
        console.log('Session saved:', data);
      } catch (error) {
        console.error('Failed to save session:', error);
      }
    }
    
    function playBackgroundMusic() {
      if (!soundEnabled || bgMusicNode) return;
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = 220;
      oscillator.type = 'sine';
      gainNode.gain.value = 0.03;
      
      oscillator.start();
      bgMusicNode = oscillator;
    }
    
    function stopBackgroundMusic() {
      if (bgMusicNode) {
        bgMusicNode.stop();
        bgMusicNode = null;
      }
    }
    
    function playSound(frequency, duration, type = 'sine', volume = 0.3) {
      if (!soundEnabled) return;
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = frequency;
      oscillator.type = type;
      gainNode.gain.value = volume;
      
      oscillator.start();
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      oscillator.stop(audioContext.currentTime + duration);
    }
    
    function playClickSound() {
      playSound(523, 0.1, 'square', 0.2);
    }
    
    function playSuccessSound() {
      playSound(523, 0.15);
      setTimeout(() => playSound(659, 0.15), 100);
      setTimeout(() => playSound(784, 0.2), 200);
    }
    
    function playErrorSound() {
      playSound(200, 0.3, 'sawtooth', 0.25);
    }
    
    function playCelebrationSound() {
      const notes = [523, 587, 659, 698, 784, 880, 988, 1047];
      notes.forEach((note, i) => {
        setTimeout(() => playSound(note, 0.15), i * 80);
      });
    }
    
    function speak(text, rate = 0.85) {
      if (!soundEnabled || !window.speechSynthesis) return;
      
      speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = rate;
      utterance.pitch = 1.1;
      utterance.volume = 1;
      
      // Show voice indicator
      const indicator = document.getElementById('voiceIndicator');
      if (indicator) {
        indicator.style.display = 'inline-block';
      }
      
      utterance.onend = () => {
        if (indicator) {
          indicator.style.display = 'none';
        }
      };
      
      speechSynthesis.speak(utterance);
    }
    
    function vibrate(pattern) {
      if (navigator.vibrate) {
        navigator.vibrate(pattern);
      }
    }
    
    function createStars() {
      const starBg = document.getElementById('starBg');
      for (let i = 0; i < 50; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.width = Math.random() * 3 + 'px';
        star.style.height = star.style.width;
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 3 + 's';
        starBg.appendChild(star);
      }
    }
    
    function getDifficulty() {
      if (currentLevel <= 3) return 'easy';
      if (currentLevel <= 7) return 'medium';
      return 'hard';
    }
    
    function calculateOptimalGridSize(words) {
      const maxWordLength = Math.max(...words.map(word => word.length));
      const wordCount = words.length;
      
      let baseSize = maxWordLength + 3;
      
      if (wordCount > 8) baseSize += 2;
      if (wordCount > 12) baseSize += 2;
      
      return Math.max(6, Math.min(10, baseSize));
    }
    
    function calculateTimeLimit(difficulty, gridSize) {
      const baseTimes = {
        easy: 180,
        medium: 240,
        hard: 300
      };
      
      const gridMultiplier = 1 + (gridSize - 8) * 0.1;
      return Math.floor(baseTimes[difficulty] * gridMultiplier);
    }
    
    function generateGrid(words) {
      gridSize = calculateOptimalGridSize(words);
      
      const grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(''));
      wordPositions = {};
      
      const sortedWords = [...words].sort((a, b) => b.length - a.length);
      
      const directions = [
        { dr: 0, dc: 1 }, { dr: 1, dc: 0 }, { dr: 1, dc: 1 },
        { dr: 0, dc: -1 }, { dr: -1, dc: 0 }, { dr: -1, dc: -1 },
        { dr: 1, dc: -1 }, { dr: -1, dc: 1 }
      ];
      
      sortedWords.forEach(word => {
        let placed = false;
        let attempts = 0;
        
        while (!placed && attempts < 500) {
          const direction = directions[Math.floor(Math.random() * directions.length)];
          
          const maxRow = gridSize - (direction.dr >= 0 ? word.length * Math.max(direction.dr, 1) : 0);
          const maxCol = gridSize - (direction.dc >= 0 ? word.length * Math.max(direction.dc, 1) : 0);
          const minRow = direction.dr < 0 ? word.length * Math.abs(direction.dr) : 0;
          const minCol = direction.dc < 0 ? word.length * Math.abs(direction.dc) : 0;
          
          if (minRow >= gridSize || minCol >= gridSize || maxRow < 0 || maxCol < 0) {
            attempts++;
            continue;
          }
          
          const startRow = Math.floor(Math.random() * (maxRow - minRow + 1)) + minRow;
          const startCol = Math.floor(Math.random() * (maxCol - minCol + 1)) + minCol;
          
          let canPlace = true;
          let positions = [];
          
          for (let i = 0; i < word.length; i++) {
            const row = startRow + i * direction.dr;
            const col = startCol + i * direction.dc;
            
            if (row < 0 || row >= gridSize || col < 0 || col >= gridSize) {
              canPlace = false;
              break;
            }
            
            if (grid[row][col] !== '' && grid[row][col] !== word[i]) {
              canPlace = false;
              break;
            }
            
            positions.push([row, col]);
          }
          
          if (canPlace) {
            positions.forEach(([r, c], i) => {
              grid[r][c] = word[i];
            });
            
            wordPositions[word] = positions;
            placed = true;
          }
          
          attempts++;
        }
        
        if (!placed) {
          bruteForcePlacement(grid, word, wordPositions, gridSize);
        }
      });
      
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (grid[i][j] === '') {
            grid[i][j] = letters[Math.floor(Math.random() * letters.length)];
          }
        }
      }
      
      return grid.flat();
    }
    
    function bruteForcePlacement(grid, word, wordPositions, size) {
      const directions = [
        { dr: 0, dc: 1 }, { dr: 1, dc: 0 }, { dr: 1, dc: 1 },
        { dr: 0, dc: -1 }, { dr: -1, dc: 0 }, { dr: -1, dc: -1 },
        { dr: 1, dc: -1 }, { dr: -1, dc: 1 }
      ];
      
      for (let startRow = 0; startRow < size; startRow++) {
        for (let startCol = 0; startCol < size; startCol++) {
          for (const direction of directions) {
            let canPlace = true;
            let positions = [];
            
            for (let i = 0; i < word.length; i++) {
              const row = startRow + i * direction.dr;
              const col = startCol + i * direction.dc;
              
              if (row < 0 || row >= size || col < 0 || col >= size) {
                canPlace = false;
                break;
              }
              
              if (grid[row][col] !== '' && grid[row][col] !== word[i]) {
                canPlace = false;
                break;
              }
              
              positions.push([row, col]);
            }
            
            if (canPlace) {
              positions.forEach(([r, c], i) => {
                grid[r][c] = word[i];
              });
              
              wordPositions[word] = positions;
              return true;
            }
          }
        }
      }
      
      return false;
    }
    
    async function initGame(skipFetch = false) {
      if (!skipFetch) {
        document.getElementById('loadingModal').classList.add('active');
        currentDifficulty = getDifficulty();
        
        const serverWords = await fetchWordsFromServer(currentDifficulty);
        
        if (serverWords && serverWords.length >= 5) {
          currentWords = serverWords;
        } else {
          const wordBank = wordBanks[currentDifficulty];
          const randomSet = wordBank[Math.floor(Math.random() * wordBank.length)];
          const wordCount = Math.min(5 + Math.floor(currentLevel / 2), 8);
          currentWords = randomSet.slice(0, wordCount);
        }
        
        gridSize = calculateOptimalGridSize(currentWords);
        gridLetters = generateGrid(currentWords);
        foundWords.clear();
        selectedCells = [];
        hintsUsed = 0;
        wordColorIndex = 0;
        
        timer = calculateTimeLimit(currentDifficulty, gridSize);
        
        document.getElementById('loadingModal').classList.remove('active');
      }
      
      renderGrid();
      renderWords();
      updateScore();
      updateTimer();
      
      document.getElementById('difficultyBadge').textContent = `Level ${currentLevel}`;
      document.getElementById('totalScore').textContent = totalScore;
      document.getElementById('sound-btn').textContent = soundEnabled ? 'üîä Sound' : 'üîá Muted';
      
      saveGameState();
    }
    
    function renderGrid() {
      const grid = document.getElementById('grid');
      grid.innerHTML = '';
      grid.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
      
      gridLetters.forEach((letter, index) => {
        const cell = document.createElement('div');
        cell.className = 'grid-cell';
        cell.textContent = letter;
        cell.dataset.index = index;
        
        const row = Math.floor(index / gridSize);
        const col = index % gridSize;
        
        let cellColorIndex = 0;
        foundWords.forEach(word => {
          cellColorIndex++;
          const positions = wordPositions[word];
          if (positions) {
            positions.forEach(([r, c]) => {
              if (r === row && c === col) {
                const colorClass = `found-cell-${((cellColorIndex - 1) % 5) + 1}`;
                cell.classList.add('found-cell', colorClass);
              }
            });
          }
        });
        
        cell.addEventListener('click', handleCellClick);
        grid.appendChild(cell);
      });
    }
    
    function renderWords() {
      const wordList = document.getElementById('word-list');
      wordList.innerHTML = '';
      
      currentWords.forEach(word => {
        const div = document.createElement('div');
        div.className = 'word-item';
        if (foundWords.has(word)) {
          div.classList.add('found');
        }
        div.dataset.word = word;
        div.textContent = word;
        wordList.appendChild(div);
      });
    }
    
    function handleCellClick(e) {
      if (!gameActive) return;
      
      playClickSound();
      vibrate(30);
      const cell = e.target;
      
      if (cell.classList.contains('found-cell') || 
          cell.classList.contains('found-cell-1') ||
          cell.classList.contains('found-cell-2') ||
          cell.classList.contains('found-cell-3') ||
          cell.classList.contains('found-cell-4') ||
          cell.classList.contains('found-cell-5')) {
        return;
      }
      
      cell.classList.toggle('selected');
      updateSelection();
    }
    
    function updateSelection() {
      const selected = document.querySelectorAll('.grid-cell.selected:not([class*="found-cell"])');
      selectedCells = Array.from(selected).map(c => ({
        element: c,
        letter: c.textContent,
        index: parseInt(c.dataset.index)
      }));
      
      checkWord();
    }
    
    function checkWord() {
      const current = selectedCells.map(c => c.letter).join('');
      const indices = selectedCells.map(c => c.index);
      
      const possibleWords = [current, current.split('').reverse().join('')];
      
      possibleWords.forEach(word => {
        if (currentWords.includes(word) && !foundWords.has(word)) {
          const positions = wordPositions[word];
          
          if (positions && isValidWordPlacement(indices, positions, gridSize)) {
            foundWords.add(word);
            wordColorIndex++;
            const colorClass = `found-cell-${((wordColorIndex - 1) % 5) + 1}`;
            
            selectedCells.forEach(c => {
              c.element.classList.remove('selected');
              c.element.classList.add('found-cell', colorClass);
            });
            
            document.querySelector(`[data-word="${word}"]`).classList.add('found');
            
            playSuccessSound();
            vibrate(100);
            speak('Great! You found ' + word);
            
            const points = word.length * 10 - (hintsUsed * 5);
            totalScore += Math.max(points, 5);
            
            updateScore();
            saveGameState();
            
            if (foundWords.size === currentWords.length) {
              setTimeout(completeLevel, 1000);
            }
            
            selectedCells = [];
          }
        }
      });
    }
    
    function isValidWordPlacement(selectedIndices, wordPositions, gridSize) {
      const wordIndices = wordPositions.map(([r, c]) => r * gridSize + c);
      
      if (arraysMatch(selectedIndices, wordIndices)) {
        return true;
      }
      
      const reversedIndices = [...wordIndices].reverse();
      if (arraysMatch(selectedIndices, reversedIndices)) {
        return true;
      }
      
      return false;
    }
    
    function arraysMatch(arr1, arr2) {
      if (arr1.length !== arr2.length) return false;
      const sorted1 = [...arr1].sort((a, b) => a - b);
      const sorted2 = [...arr2].sort((a, b) => a - b);
      return sorted1.every((val, idx) => val === sorted2[idx]);
    }
    
    function updateScore() {
      const scoreText = `${foundWords.size}/${currentWords.length}`;
      document.getElementById('score').textContent = scoreText;
      
      const progress = (foundWords.size / currentWords.length) * 100;
      document.getElementById('progressBar').style.width = progress + '%';
      
      document.getElementById('totalScore').textContent = totalScore;
    }
    
    function updateTimer() {
      if (timer <= 0) {
        endGame();
        return;
      }
      
      const m = Math.floor(timer / 60);
      const s = timer % 60;
      const timerDisplay = document.getElementById('timer');
      timerDisplay.textContent = `${m}:${s.toString().padStart(2, '0')}`;
      
      if (timer === 20) {
        timerDisplay.classList.add('timer-danger');
        playErrorSound();
        vibrate(200);
        speak('Hurry! Only 20 seconds left!');
      } else if (timer === 10) {
        speak('10 seconds!');
      } else if (timer > 20) {
        timerDisplay.classList.remove('timer-danger');
      }
      
      timer--;
      saveGameState();
    }
    
    function completeLevel() {
      gameActive = false;
      clearInterval(timerInterval);
      
      playCelebrationSound();
      vibrate([100, 50, 100, 50, 100]);
      
      const timeBonus = timer * 2;
      totalScore += timeBonus;
      
      saveGameSession();
      saveGameState();
      
      document.getElementById('completionMessage').textContent = `You found all ${currentWords.length} words!`;
      document.getElementById('completionStats').textContent = `Score: ${totalScore} points | Time Bonus: ${timeBonus}`;
      document.getElementById('totalScore').textContent = totalScore;
      
      createConfetti();
      
      setTimeout(() => {
        document.getElementById('completionModal').classList.add('active');
        speak('Amazing! You completed the level! Your score is ' + totalScore + ' points!');
      }, 1500);
    }
    
    function endGame() {
      gameActive = false;
      clearInterval(timerInterval);
      
      playErrorSound();
      vibrate(300);
      
      saveGameState();
      
      document.getElementById('timeUpMessage').textContent = `You found ${foundWords.size}/${currentWords.length} words!`;
      document.getElementById('timeUpModal').classList.add('active');
      
      speak('Time is up! You found ' + foundWords.size + ' words. Let\'s try the next level!');
    }
    
    function nextLevel() {
      currentLevel++;
      document.getElementById('completionModal').classList.remove('active');
      document.getElementById('timeUpModal').classList.remove('active');
      initGame();
      gameActive = true;
      timerInterval = setInterval(updateTimer, 1000);
    }
    
    function startGame() {
      document.getElementById('tutorialModal').classList.remove('active');
      speak('Welcome to Word Search Adventure! Find all the hidden words in the grid. Good luck!');
      initGame();
      gameActive = true;
      timerInterval = setInterval(updateTimer, 1000);
      playBackgroundMusic();
    }
    
    function resumeGame() {
      document.getElementById('tutorialModal').classList.remove('active');
      speak('Welcome back! Continue finding the hidden words!');
      initGame(true);
      gameActive = true;
      timerInterval = setInterval(updateTimer, 1000);
      if (soundEnabled) {
        playBackgroundMusic();
      }
    }
    
    function closeHintModal() {
      document.getElementById('hintModal').classList.remove('active');
    }
    
    function createConfetti() {
      const colors = ['#FFC107', '#8BC34A', '#03A9F4', '#E91E63', '#9C27B0'];
      const confettiCount = 50;
      
      for (let i = 0; i < confettiCount; i++) {
        setTimeout(() => {
          const confetti = document.createElement('div');
          confetti.style.position = 'fixed';
          confetti.style.width = '10px';
          confetti.style.height = '10px';
          confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.left = Math.random() * 100 + '%';
          confetti.style.top = '-10px';
          confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
          confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
          confetti.style.animation = `fall ${2 + Math.random() * 2}s linear`;
          confetti.style.zIndex = '1000';
          document.body.appendChild(confetti);
          setTimeout(() => confetti.remove(), 5000);
        }, i * 30);
      }
    }
    
    // Event Listeners
    document.getElementById('hint-btn').addEventListener('click', () => {
      if (!gameActive) return;
      
      const unfound = currentWords.filter(w => !foundWords.has(w));
      if (unfound.length === 0) {
        speak('You found all the words! Great job!');
        document.getElementById('hintMessage').textContent = 'Great job!';
        document.getElementById('hintDetail').textContent = 'You have found all the words!';
        document.getElementById('hintModal').classList.add('active');
        return;
      }
      
      const hintWord = unfound[0];
      hintsUsed++;
      playClickSound();
      vibrate(50);
      speak('Try to find ' + hintWord);
      
      saveGameState();
      
      document.getElementById('hintMessage').textContent = `Look for: "${hintWord}"`;
      document.getElementById('hintDetail').textContent = `First letter: ${hintWord[0]} | Length: ${hintWord.length} letters`;
      document.getElementById('hintModal').classList.add('active');
    });
    
    document.getElementById('clear-btn').addEventListener('click', () => {
      if (!gameActive) return;
      
      document.querySelectorAll('.grid-cell.selected:not([class*="found-cell"])').forEach(cell => {
        cell.classList.remove('selected');
      });
      selectedCells = [];
      playClickSound();
      vibrate(50);
    });
    
    document.getElementById('sound-btn').addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      const btn = document.getElementById('sound-btn');
      btn.textContent = soundEnabled ? 'üîä Sound' : 'üîá Muted';
      
      if (soundEnabled) {
        playBackgroundMusic();
        playClickSound();
        speak('Sound is on!');
      } else {
        stopBackgroundMusic();
        speechSynthesis.cancel();
      }
      
      vibrate(50);
      saveGameState();
    });
    
    // Initialize game on page load
    window.addEventListener('load', () => {
      createStars();
      
      if (loadGameState()) {
        console.log('Resuming previous game...');
        resumeGame();
      } else {
        console.log('Starting new game...');
        document.getElementById('tutorialModal').classList.add('active');
      }
    });
    
    window.addEventListener('beforeunload', () => {
      if (gameActive) {
        saveGameState();
      }
    });
    
    window.addEventListener('beforeunload', (e) => {
      if (gameActive && foundWords.size > 0) {
        e.preventDefault();
        e.returnValue = '';
      }
    });

    // Mobile app behaviors
    document.addEventListener('touchstart', function (event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
    }, { passive: false });

    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
      const now = (new Date()).getTime();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, false);

    let lastTouchStart = 0;
    document.addEventListener('touchstart', function (event) {
      const now = (new Date()).getTime();
      if (now - lastTouchStart <= 300) {
        event.preventDefault();
      }
      lastTouchStart = now;
    }, false);

    document.addEventListener('contextmenu', function (e) {
      e.preventDefault();
    }, false);

    document.addEventListener('selectstart', function (e) {
      e.preventDefault();
    }, false);

    document.documentElement.style.scrollBehavior = 'smooth';

    document.querySelectorAll('button').forEach(btn => {
      btn.addEventListener('click', () => {
        vibrate(50);
      });
    });

    console.log('Word Search Adventure - Ready to play!');
  </script>
  {% include 'bottom_nav.html' %}
</body>
</html>